## nginx configuration
## Ref: https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/index.md

commonLabels: {}


controller:
    name: controller
    image:
        
        chroot: false
        registry: registry.k8s.io
        image: ingress-nginx/controller
        tag: "v1.6.4"
        digest: sha256:15be4666c53052484dd2992efacf2f50ea77a78ae8aa21ccd91af6baaa7ea22f
        digestChroot: sha256:0de01e2c316c3ca7847ca13b32d077af7910d07f21a4a82f81061839764f8f81
        pullPolicy: IfNotPresent
        # www-data -> uid 101
        runAsUser: 101
        allowPrivilegeEscalation: true
    # -- Use an existing PSP instead of creating one
    existingPsp: ""
    # -- Configures the controller container name
    containerName: controller
    # -- Configures the ports that the nginx-controller listens on
    containerPort:
        http: 80
        https: 443
    config: {}
    configAnnotations: {}
    proxySetHeaders: {}
    addHeaders: {}
    dnsConfig: {}
    hostname: {}
    dnsPolicy: ClusterFirst
    reportNodeInternalIp: false
    watchIngressWithoutClass: false
    ingressClassByName: false
    enableTopologyAwareRouting: false
    allowSnippetAnnotations: true
    hostNetwork: false
    hostPort:
        enabled: false
        ports:
            http: 80
            https: 443
    electionID: ""
    ingressClassResource:
        name: nginx
        enabled: true
        default: false
        controllerValue: "k8s.io/ingress-nginx"

        parameters: {}

    ingressClass: nginx
  
    podLabels: {}

    podSecurityContext: {}
 
    sysctls: {}

    publishService:

        enabled: true

        pathOverride: ""

    scope:

        enabled: false

        namespace: ""

        namespaceSelector: ""

    configMapNamespace: ""
    tcp:

        configMapNamespace: ""

        annotations: {}
    udp:

        configMapNamespace: ""

        annotations: {}

    maxmindLicenseKey: ""

    extraArgs: {}

    extraEnvs: []
    kind: Deployment

    annotations: {}

    labels: {}

    updateStrategy: {}

    minReadySeconds: 0

    tolerations: []

    affinity: {}
    topologySpreadConstraints: []

    terminationGracePeriodSeconds: 300

    nodeSelector:
        kubernetes.io/os: linux

    livenessProbe:
        httpGet:

            path: "/healthz"
            port: 10254
            scheme: HTTP
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 1
        successThreshold: 1
        failureThreshold: 5
    readinessProbe:
        httpGet:
            # should match container.healthCheckPath
            path: "/healthz"
            port: 10254
            scheme: HTTP
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 1
        successThreshold: 1
        failureThreshold: 3

    healthCheckPath: "/healthz"

    healthCheckHost: ""

    podAnnotations: {}
    replicaCount: 1
  
    minAvailable: 1
    resources:
        requests:
            cpu: 100m
            memory: 90Mi

    autoscaling:
        apiVersion: autoscaling/v2
        enabled: false
        annotations: {}
        minReplicas: 1
        maxReplicas: 11
        targetCPUUtilizationPercentage: 50
        targetMemoryUtilizationPercentage: 50
        behavior: {}
    autoscalingTemplate: []
    keda:
        apiVersion: "keda.sh/v1alpha1"
        enabled: false
        minReplicas: 1
        maxReplicas: 11
        pollingInterval: 30
        cooldownPeriod: 300
        restoreToOriginalReplicaCount: false
        scaledObject:
            annotations: {}
        triggers: []

        behavior: {}
    enableMimalloc: true
    customTemplate:
        configMapName: ""
        configMapKey: ""
    service:
        enabled: true
        appProtocol: true
        annotations: {}
        labels: {}
        externalIPs: []
        loadBalancerIP: ""
        loadBalancerSourceRanges: []
        enableHttp: true
        enableHttps: true
        ipFamilyPolicy: "SingleStack"
        ipFamilies:
            - IPv4
        ports:
            http: 80
            https: 443
        targetPorts:
            http: http
            https: https
        type: LoadBalancer
        nodePorts:
            http: ""
            https: ""
            tcp: {}
            udp: {}
        external:
            enabled: true
        internal:
            # -- Enables an additional internal load balancer (besides the external one).
            enabled: false
            # -- Annotations are mandatory for the load balancer to come up. Varies with the cloud service.
            annotations: {}
            loadBalancerSourceRanges: []
    shareProcessNamespace: false
    extraContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    extraInitContainers: []
    extraModules: []

    opentelemetry:
        enabled: false
        image: registry.k8s.io/ingress-nginx/opentelemetry:v20230107-helm-chart-4.4.2-2-g96b3d2165@sha256:331b9bebd6acfcd2d3048abbdd86555f5be76b7e3d0b5af4300b04235c6056c9
        containerSecurityContext:
            allowPrivilegeEscalation: false
    admissionWebhooks:
        annotations: {}
        enabled: true
        # -- Additional environment variables to set
        extraEnvs: []
        failurePolicy: Fail
        # timeoutSeconds: 10
        port: 8443
        certificate: "/usr/local/certificates/cert"
        key: "/usr/local/certificates/key"
        namespaceSelector: {}
        objectSelector: {}
        # -- Labels to be added to admission webhooks
        labels: {}
        # -- Use an existing PSP instead of creating one
        existingPsp: ""
        networkPolicyEnabled: false
        service:
            annotations: {}
            # clusterIP: ""
            externalIPs: []
            # loadBalancerIP: ""
            loadBalancerSourceRanges: []
            servicePort: 443
            type: ClusterIP
        createSecretJob:
            securityContext:
                allowPrivilegeEscalation: false
            resources: {}
            # limits:
            #   cpu: 10m
            #   memory: 20Mi
            # requests:
            #   cpu: 10m
            #   memory: 20Mi
        patchWebhookJob:
            securityContext:
                allowPrivilegeEscalation: false
            resources: {}
        patch:
            enabled: true
            image:
                registry: registry.k8s.io
                image: ingress-nginx/kube-webhook-certgen
                ## for backwards compatibility consider setting the full image url via the repository value below
                ## use *either* current default registry/image or repository format or installing chart by providing the values.yaml will fail
                ## repository:
                tag: v20220916-gd32f8c343
                digest: sha256:39c5b2e3310dc4264d638ad28d9d1d96c4cbb2b2dcfb52368fe4e3c63f61e10f
                pullPolicy: IfNotPresent
            # -- Provide a priority class name to the webhook patching job
            ##
            priorityClassName: ""
            podAnnotations: {}
            nodeSelector:
                kubernetes.io/os: linux
            tolerations: []
            # -- Labels to be added to patch job resources
            labels: {}
            securityContext:
                runAsNonRoot: true
                runAsUser: 2000
                fsGroup: 2000
        # Use certmanager to generate webhook certs
        certManager:
            enabled: false
            # self-signed root certificate
            rootCert:
                # default to be 5y
                duration: ""
            admissionCert:
                # default to be 1y
                duration: ""
                # issuerRef:
                #   name: "issuer"
                #   kind: "ClusterIssuer"
    metrics:
        port: 10254
        portName: metrics
        # if this port is changed, change healthz-port: in extraArgs: accordingly
        enabled: false
        service:
            annotations: {}

            labels: {}

            externalIPs: []
            # loadBalancerIP: ""
            loadBalancerSourceRanges: []
            servicePort: 10254
            type: ClusterIP

        serviceMonitor:
            enabled: false
            additionalLabels: {}
            namespace: ""
            namespaceSelector: {}
            scrapeInterval: 30s
            # honorLabels: true
            targetLabels: []
            relabelings: []
            metricRelabelings: []
        prometheusRule:
            enabled: false
            additionalLabels: {}
            # namespace: ""
            rules: []
     lifecycle:
        preStop:
            exec:
                command:
                    - /wait-shutdown
    priorityClassName: ""
# -- Rollback limit
##
revisionHistoryLimit: 10
## Default 404 backend
##
defaultBackend:
    ##
    enabled: false
    name: defaultbackend
    image:
        registry: registry.k8s.io
        image: defaultbackend-amd64
        tag: "1.5"
        pullPolicy: IfNotPresent
        # nobody user -> uid 65534
        runAsUser: 65534
        runAsNonRoot: true
        readOnlyRootFilesystem: true
        allowPrivilegeEscalation: false
    # -- Use an existing PSP instead of creating one
    existingPsp: ""
    extraArgs: {}
    serviceAccount:
        create: true
        name: ""
        automountServiceAccountToken: true

    extraEnvs: []
    port: 8080

    livenessProbe:
        failureThreshold: 3
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
    readinessProbe:
        failureThreshold: 6
        initialDelaySeconds: 0
        periodSeconds: 5
        successThreshold: 1
        timeoutSeconds: 5

    updateStrategy: {}

    minReadySeconds: 0
 
    tolerations: []

    affinity: {}

    podSecurityContext: {}

    containerSecurityContext: {}

    podLabels: {}
    nodeSelector:
        kubernetes.io/os: linux

    podAnnotations: {}
    replicaCount: 1
    minAvailable: 1
    resources: {}

    extraVolumeMounts: []

    extraVolumes: []

    autoscaling:
        apiVersion: autoscaling/v2
        annotations: {}
        enabled: false
        minReplicas: 1
        maxReplicas: 2
        targetCPUUtilizationPercentage: 50
        targetMemoryUtilizationPercentage: 50
    service:
        annotations: {}

        externalIPs: []
        # loadBalancerIP: ""
        loadBalancerSourceRanges: []
        servicePort: 80
        type: ClusterIP
    priorityClassName: ""

    labels: {}
rbac:
    create: true
    scope: false
podSecurityPolicy:
    enabled: false
serviceAccount:
    create: true
    name: ""
    automountServiceAccountToken: true
    annotations: {}
imagePullSecrets: []
tcp: {}
udp: {}
portNamePrefix: ""
dhParam: